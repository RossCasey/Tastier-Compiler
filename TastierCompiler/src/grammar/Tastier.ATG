COMPILER Tastier

//Ross Casey - 12301716

/*
  Strings are stored in data memory as a sequence of values. The first value
  of which is its length. Eg the string "hello" would be stored in memory as:
    [5][h][e][l][l][o]
     0  1  2  3  4  5

  where the characters are stored as their integer equivalent.

  A string variable stores a pointer to the start of a string in memory. So
  a variable assigned to the above example would store the value 0. The string
  can then be accessed by the machine by reading the value in memory pointed to
  by the variable and then loaded the next n values in memory where n is the
  value pointed to by the variable.
*/

/*
  The  and nextHeapAddress are needed in order to compute where
  sequential values (in this case strings) can be placed in data memory.
  Global variables start at address 3 increment so there is no room to place
  a block of memory that could be used for strings. To fix this problem strings
  are stored in memory only after all other values have been allocated memory
  space. This is done by placing temporary instructions into the program when
  using StoG to store a string memory. These temporary instructions contain
  relative address which can be used later to calculate its absolute address.
  The temporary instructions take the from:
      new Instuction("StrReplace","<relative address>")
  The nextHeapAddress variable keeps track of the next available address in memory.
  This value is incremented as new values are stored. This allows for the
  computation of the temporary, relative address.

  The  is incremented every time a global variable is allocated
  memory. This will allow the parser to go back and insert the absolute addresses later.
  Once the program has been parsed fully, the parser then needs to go back and edit the
  address used for strings. It iterates through all instructions and change them to
      new Instruction("", "Const (<relative address> +)")

  This allows for the allocation of as many global variables as necessary and there
  is no wasted memory as all strings are assigned to the very next addresses in data
  memory.
*/

  /*
    Address 0 is the pointer to the next free address in the heap
    Address 1 is needed as a temporary storage location for calculating the size of a memory allocation
  */
  int nextHeapAddress = 2;




/*
  When dealing with write statements with more than 1 argument it is necessary to
  know the number of arguments that were passed to the write statement. This variable
  allows us to keep track of the number of arguments in the write statement.
*/
  int numArgs = 0;



/*
  First, let's declare all the types we're going to use.
*/

  int maxSystemType = 3;
  int typesDefined = 4;

  enum TastierType : int {   // types for variables
    Undefined,
    Integer,
    Boolean,
    String        //new string type
  };

  /*
    new kind for constants. This stops us from re-assigning a constant as
    only Variable Kinds can be reassigned.
  */
  enum TastierKind : int {  // kinds of symbol
    Var,
    Proc,
    Const
  };

/*
  You'll notice some type aliases, such as the one just below, are commented
  out. This is because C# only allows using-alias-directives outside of a
  class, while class-inheritance directives are allowed inside. So the
  snippet immediately below is illegal in here. To complicate matters
  further, the C# runtime does not properly handle class-inheritance
  directives for Tuples (it forces you to write some useless methods). For
  these reasons, the type aliases which alias Tuples can be found in
  Parser.frame, but they're documented in this file, with the rest.
*/

  //using Symbol = System.Tuple<string, int, int, int, int, int>;

/*
  A Symbol is a name with a type and a kind. The first int in the
  tuple is the kind, and the second int is the type. We'll use these to
  represent declared names in the program.

  For each Symbol which is a variable, we have to allocate some storage, so
  the variable lives at some address in memory. The address of a variable on
  the stack at runtime has two components. The first component is which
  stack frame it's in, relative to the current procedure. If the variable is
  declared in the procedure that's currently executing, then it will be in
  that procedure's stack frame. If it's declared in the procedure that
  called the currently active one, then it'll be in the caller's stack
  frame, and so on. The first component is the offset that says how many
  frames up the chain of procedure calls to look for the variable. The
  second component is simply the location of the variable in the stack frame
  where it lives.

  The third int in the symbol is the stack frame on which the variable
  lives, and the fourth int is the index in that stack frame. Since
  variables which are declared in the global scope aren't inside any
  function, they don't have a stack frame to go into. In this compiler, our
  convention is to put these variables at an address in the data memory. If
  the variable was declared in the global scope, the fourth field in the
  Symbol will be zero, and we know that the next field is an address in
  global memory, not on the stack.

  Procedures, on the other hand, are just sets of instructions. A procedure
  is not data, so it isn't stored on the stack or in memory, but is just a
  particular part of the list of instructions in the program being run. If
  the symbol is the name of a procedure, we'll store a -1 in the address
  field (5).

  When the program is being run, the code will be loaded into the machine's
  instruction memory, and the procedure will have an address there. However,
  it's easier for us to just give the procedure a unique label, instead of
  remembering what address it lives at. The assembler will take care of
  converting the label into an address when it encounters a JMP, FJMP or
  CALL instruction with that label as a target.

  To summarize:
    * Symbol.Item1 -> name
    * Symbol.Item2 -> kind
    * Symbol.Item3 -> type
    * Symbol.Item4 -> stack frame pointer
    * Symbol.Item5 -> variable's address in the stack frame pointed to by
                      Item4, -1 if procedure
    * Symbol.Item6 -> The dimensions of the item. If > 0 then it's an array.
*/

  class Scope : Stack<Symbol> {}

/*
  A scope contains a stack of symbol definitions. Every time we come across
  a new local variable declaration, we can just push it onto the stack. We'll
  use the position of the variable in the stack to represent its address in
  the stack frame of the procedure in which it is defined. In other words, the
  variable at the bottom of the stack goes at location 0 in the stack frame,
  the next variable at location 1, and so on.
*/

  //using Instruction = Tuple<string, string>;
  class Program : List<Instruction> {}

/*
  A program is just a list of instructions. When the program is loaded into
  the machine's instruction memory, the instructions will be laid out in the
  same order that they appear in this list. Because of this, we can use the
  location of an instruction in the list as its address in instruction memory.
  Labels are just names for particular locations in the list of instructions
  that make up the program.

  The first component of all instructions is a label, which can be empty.
  The second component is the actual instruction itself.

  To summarize:
    * Instruction.Item1 -> label
    * Instruction.Item2 -> the actual instruction, as a string
*/

Stack<Scope> openScopes = new Stack<Scope>();
Scope externalDeclarations = new Scope();

/*
  Every time we encounter a new procedure declaration in the program, we want
  to make sure that expressions inside the procedure see all of the variables
  that were in scope at the point where the procedure was defined. We also
  want to make sure that expressions outside the procedure do not see the
  procedure's local variables. Every time we encounter a procedure, we'll push
  a new scope on the stack of open scopes. When the procedure ends, we can pop
  it off and continue, knowing that the local variables defined in the
  procedure cannot be seen outside, since we've popped the scope which
  contains them off the stack.
*/

Program program = new Program();
Program header = new Program();

/*
  Instuctions that are not inside a function in the assmebly language do not
  get executed. This means that even thought the constants are outside of the
  functions, they must be placed within a function in order to be executed.

  The boolean below "constantsDeclared" keeps track of whether any constants have
  been declared. If they have then we need to create a function to place them in.
  If not we need to insert a empty function that has no operations as the machine
  calls ConstDecl as the first function to execute before calling Main. The
  ConstDecl function is then called, which will allocate and assign the constants
  and then Main is called, starting the program.
*/
bool constantsDeclared = false;

Stack<string> openProcedureDeclarations = new Stack<string>();

/*
  In order to implement the "shadowing" of global procedures by local procedures
  properly, we need to generate a label for local procedures that is different
  from the label given to procedures of the same name in outer scopes. See the
  test case program "procedure-label-shadowing.TAS" for an example of why this
  is important. In order to make labels unique, when we encounter a non-global
  procedure declaration called "foo" (for example), we'll give it the label
  "enclosingProcedureName$foo" for all enclosing procedures. So if it's at
  nesting level 2, it'll get the label "outermost$nextoutermost$foo". Let's
  make a function that does this label generation given the set of open
  procedures which enclose some new procedure name.
*/

string generateProcedureName(string name) {
  if (openProcedureDeclarations.Count == 0) {
    return name;
  } else {
    string temp = name;
    foreach (string s in openProcedureDeclarations) {
      temp = s + "$" + temp;
    }
    return temp;
  }
}

/*
  We also need a function that figures out, when we call a procedure from some
  scope, what label to call. This is where we actually implement the shadowing;
  the innermost procedure with that name should be called, so we have to figure
  out what the label for that procedure is.
*/

string getLabelForProcedureName(int lexicalLevelDifference, string name) {
  /*
     We want to skip <lexicalLevelDifference> labels backwards, but compose
     a label that incorporates the names of all the enclosing procedures up
     to that point. A lexical level difference of zero indicates a procedure
     defined in the current scope; a difference of 1 indicates a procedure
     defined in the enclosing scope, and so on.
  */
  int numOpenProcedures = openProcedureDeclarations.Count;
  int numNamesToUse = (numOpenProcedures - lexicalLevelDifference);
  string theLabel = name;

  /*
    We need to concatenate the first <numNamesToUse> labels with a "$" to
    get the name of the label we need to call.
  */

  var names = openProcedureDeclarations.Take(numNamesToUse);

  foreach (string s in names) {
      theLabel = s + "$" + theLabel;
  }

  return theLabel;
}

Stack<string> openLabels = new Stack<string>();
int labelSeed = 0;

string generateLabel() {
  return "L$"+labelSeed++;
}

/*
  Sometimes, we need to jump over a block of code which we're about to
  generate (for example, at the start of a loop, if the test fails, we have
  to jump to the end of the loop). Because it hasn't been generated yet, we
  don't know how long it will be (in the case of the loop, we don't know how
  many instructions will be in the loop body until we actually generate the
  code, and count them). In this case, we can make up a new label for "the
  end of the loop" and emit a jump to that label. When we get to the end of
  the loop, we can put the label in, so that the jump will go to the
  labelled location. Since we can have loops within loops, we need to keep
  track of which label is the one that we are currently trying to jump to,
  and we need to make sure they go in the right order. We'll use a stack to
  store the labels for all of the forward jumps which are active. Every time
  we need to do a forward jump, we'll generate a label, emit a jump to that
  label, and push it on the stack. When we get to the end of the loop, we'll
  put the label in, and pop it off the stack.
*/


//stores the lists of variables for each record
class RecordVariables : List<List<Symbol>> {}

//stores the name of a record types against the index that its symbols are stored at
class RecordTypes : List<RecordType> {}

RecordVariables recordVariables = new RecordVariables();
RecordTypes recordTypes = new RecordTypes();


//keeps track of the next available index number for record types
int recordsDefined = 0;



Symbol _lookup(Scope scope, string name) {
  foreach (Symbol s in scope) {
      if (s.Item1 == name) {
        return s;
      }
  }
  return null;
}

Symbol lookup(Stack<Scope> scopes, string name) {
  int stackFrameOffset = 0;
  int variableOffset = 0;

  foreach (Scope scope in scopes) {
    foreach (Symbol s in scope) {
      if (s.Item1 == name) {
        return s;
      }
      else {
        variableOffset += 1;
      }
    }
    stackFrameOffset += 1;
    variableOffset = 0;
  }
  return null; // if the name wasn't found in any open scopes.
}


//modify
Symbol recordVariableLookup(int type, string varName) {
  int variableIndex = -1;
  foreach(RecordType rec in recordTypes) {
    if(rec.Item2 == type) {
      variableIndex = rec.Item3;
    }
  }

  foreach(Symbol s in recordVariables.ElementAt(variableIndex)) {
    if(s.Item1.Equals(varName)) {
      return s;
    }
  }
  return null;
}


/*
  You may notice that when we use a LoadG or StoG instruction, we add 3 to
  the address of the item being loaded or stored. This is because the
  control and status registers of the machine are mapped in at addresses 0,
  1, and 2 in data memory, so we cannot use those locations for storing
  variables. If you want to load rtp, rbp, or rpc onto the stack to
  manipulate them, you can LoadG and StoG to those locations.
*/

/*--------------------------------------------------------------------------*/

CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  special = " ,.!Â£$%^&*()-_=+<>?/#|`~:;".         //special characters for strings
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  quote = '\"'.
  dot = '.'.

TOKENS
  access = dot.
  ident  = letter {letter | digit}.
  number = digit {digit}.
  string = quote {letter | digit | special} quote.  //new string

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*------------------------------------------------------------------------*/

AddOp<out Instruction inst>
=                               (.  inst = new Instruction("", "Add"); .)
  ( '+'
  | '-'                         (.  inst = new Instruction("", "Sub"); .)
  ).

/*------------------------------------------------------------------------*/

Expr<out int type, out int dim> (.  int type1; int dim1; Instruction inst; .)
= SimExpr<out type, out dim>
  [ RelOp<out inst>
    SimExpr<out type1, out dim1> (.
                                    if ((type != type1) || (dim != dim1)) {
                                      SemErr("incompatible types");
                                    }
                                    else {
                                      program.Add(inst);
                                      type = (int)TastierType.Boolean;
                                    }
                                .)
  ].

/*------------------------------------------------------------------------*/

Factor<out int type,out int dim>  (.  int n; Symbol sym; string name;  int arrayAccessType; int dim1; .)
=                                 (.  type = (int)TastierType.Undefined; dim = 0; .)
  ( Ident<out name>               (.
                                    bool isExternal = false; //CS3071 students can ignore external declarations, since they only deal with compilation of single files.
                                    sym = lookup(openScopes, name);
                                    if (sym == null) {
                                      sym = _lookup(externalDeclarations, name);
                                      isExternal = true;
                                    }
                                    if (sym == null) {
                                      SemErr("reference to undefined variable " + name);
                                    } else {
                                      type = sym.Item3;
                                      dim = sym.Item6;
                                      if (sym.Item4 == 0) {
                                        if (isExternal) {
                                          program.Add(new Instruction("", "LoadG " + sym.Item1));
                                          // if the symbol is external, we load it by name. The linker will resolve the name to an address.
                                        } else {
                                          program.Add(new Instruction("", "LoadG " + (sym.Item5+3)));
                                        }
                                      } else {
                                        int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                        program.Add(new Instruction("", "Load " + lexicalLevelDifference + " " + sym.Item5));
                                      }
                                    }
                                .)
    {
    (access                    (.
                                    if(sym.Item3 <= maxSystemType || dim != 0) {
                                      SemErr("The access operator \'.\' can only be used for record reference variables");
                                    }
                                .)
      Ident<out name>          (.
                                    sym = recordVariableLookup(sym.Item3,name);
                                    if(sym == null) {
                                      SemErr(name + " is not defined in referenced record");
                                    } else {
                                      type = sym.Item3;
                                      dim = sym.Item6;
                                      program.Add(new Instruction("","Const " + (sym.Item5)));
                                      program.Add(new Instruction("","Add"));
                                      program.Add(new Instruction("","MemLoad"));
                                    }
                                .)

    |'['
      Expr<out arrayAccessType, out dim1> (.
                                  dim--;
                                  if(dim < 0) {
                                    SemErr("Too many array accesses [ ]");
                                  }

                                  if((arrayAccessType != (int)TastierType.Integer) ||
                                    (dim1 != 0)){
                                    SemErr("Integer type expected for array access");
                                  }

                                  program.Add(new Instruction("","Add"));
                                  program.Add(new Instruction("","MemLoad"));
                                .)
      ']'
    | '('')'                    (.
                                  if ((TastierKind)sym.Item2 != TastierKind.Proc) {
                                    SemErr("object is not a procedure");
                                  }

                                  int currentStackLevel = openScopes.Count;
                                  int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4);
                                  string procedureLabel = getLabelForProcedureName(lexicalLevelDifference, sym.Item1);

                                  type = sym.Item3;
                                  dim = sym.Item6; 

                                  if(sym.Item3 == (int)TastierType.Undefined) {
                                    program.Add(new Instruction("", "Call " + lexicalLevelDifference + " " + procedureLabel));
                                  } else {
                                    program.Add(new Instruction("", "CallNonVoid " + lexicalLevelDifference + " " + procedureLabel));
                                  }
                                .)
    )
    }

  | number                      (.
                                    n = Convert.ToInt32(t.val);
                                    program.Add(new Instruction("", "Const " + n));
                                    type = (int)TastierType.Integer;
                                    dim = 0;
                                .)
  | '-'
    Factor<out type,out dim>    (.
                                    if ((type != (int)TastierType.Integer) || (dim != 0)) {
                                      SemErr("integer type expected");
                                      type = (int)TastierType.Integer;
                                      dim = 0;
                                    }
                                    program.Add(new Instruction("", "Neg"));
                                    program.Add(new Instruction("", "Const 1"));
                                    program.Add(new Instruction("", "Add"));
                                .)
  | "true"                      (.  program.Add(new Instruction("", "Const " + 1)); type = (int)TastierType.Boolean; dim = 0; .)
  | "false"                     (.  program.Add(new Instruction("", "Const " + 0)); type = (int)TastierType.Boolean; dim = 0; .)
  | string                      (.
                                    /*
                                      Strings are stored in the heap. The string is stored
                                      as its length followed by a sequence of values.
                                      The values are stored in memory by first placing them on
                                      the stack and then using StoG to store them in data memory.
                                      This is done for the length and every value in the string.
                                    */
                                    string value = t.val;
                                    char[] array = value.ToCharArray();
                                    int stringAddress = nextHeapAddress;
                                    //store string length in memory
                                    program.Add(new Instruction("", "Const " + (array.Count()-2)));
                                    //store start of string in the next available address in heap memory
                                    program.Add(new Instruction("","StoG " + (stringAddress + 3)));
                                    nextHeapAddress++;
                                    //store values into memory
                                    for(int i=1; i< array.Count()-1; i++) {
                                      program.Add(new Instruction("", "Const " + (int)array[i]));
                                      //store each digit into memory
                                      program.Add(new Instruction("","StoG " + (nextHeapAddress+3)));
                                      nextHeapAddress++;
                                    }
                                    program.Add(new Instruction("","Const " + (stringAddress + 3)));
                                    type = (int)TastierType.String;
                                    dim = 0;
                                  .)
  ).

/*------------------------------------------------------------------------*/

Ident<out string name>
= ident                         (.  name = t.val; .).

/*------------------------------------------------------------------------*/

MulOp<out Instruction inst>
=                               (.  inst = new Instruction("", "Mul"); .)
  ( '*'
  | '/'                         (.  inst = new Instruction("", "Div"); .)
  ).

/*------------------------------------------------------------------------*/

ProcDecl                        (.  string name; string label; Scope currentScope = openScopes.Peek(); int enterInstLocation = 0; bool external = false;
                                    int type = 0; int dimensions = 0; string typeName; bool returnDeclared = false; int returnType; int returnDim; .)
= "function"
  ("void"                       (.
                                    type = (int)TastierType.Undefined;
                                .)
  | Type<out type>
  | "record" Ident<out typeName> (.
                                    bool found = false;
                                    foreach(RecordType rec in recordTypes) {
                                      if(rec.Item1.Equals(typeName)) {
                                        found = true;
                                        type = rec.Item2;
                                      }
                                    }
                                    if(!found) {
                                      SemErr("Record type " + typeName + " has not been declared");
                                      type = -1;
                                    }
                                .)
  )
  {
    '[' ']'                     (.
                                    if(type == (int)TastierType.Undefined) {
                                      SemErr("It is not possible to have an array of void");
                                    } else {
                                      dimensions++;
                                    }
                                .)
  }
  Ident<out name>               (.
                                    currentScope.Push(new Symbol(name, (int)TastierKind.Proc, type, openScopes.Count, -1,dimensions));
                                    openScopes.Push(new Scope());
                                    currentScope = openScopes.Peek();
                                .)
  '(' ')'
  '{'                           (.
                                    program.Add(new Instruction("", "Enter 0"));
                                    enterInstLocation = program.Count - 1;
                                    if(name=="ConstDecl") {
                                      SemErr("ConstDecl is a protected procedure name. Please rename your procedure.");
                                    }
                                    label = generateProcedureName(name);
                                    openProcedureDeclarations.Push(name);
                                    /*
                                      Enter is supposed to have as an
                                      argument the next free address on the
                                      stack, but until we know how many
                                      local variables are in this procedure,
                                      we don't know what that is. We'll keep
                                      track of where we put the Enter
                                      instruction in the program so that
                                      later, when we know how many spaces on
                                      the stack have been allocated, we can
                                      put the right value in.
                                    */
                                .)

  { VarDecl<external> | Stat |  (.
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    /*
                                      We need to jump over procedure
                                      definitions because otherwise we'll
                                      execute all the code inside them!
                                      Procedures should only be entered via
                                      a Call instruction.
                                    */
                                .)
    ProcDecl                    (. program.Add(new Instruction(openLabels.Pop(), "Nop")); .)
  }

  [
    "return"                    (.
                                    if(type == (int)TastierType.Undefined) {
                                      SemErr("Cannot return a value from a void function");
                                    }
                                .)
    Expr<out returnType, out returnDim>
                                (.
                                    if((type != returnType) || (dimensions != returnDim)) {
                                      SemErr("Function type and return type do not match");
                                    }
                                    returnDeclared = true;

                                    //moves the value at the top of the stack into the slot
                                    //designated for return values
                                    program.Add(new Instruction("", "RetValue"));
                                .)
   ';'
  ]
  '}'                           (.
                                    if((type != (int)TastierType.Undefined) && (!returnDeclared)) {
                                      SemErr("A return value has not been declared for this non-void function");
                                    }

                                    program.Add(new Instruction("", "Leave"));
                                    program.Add(new Instruction("", "Ret"));
                                    openScopes.Pop();
                                    // now we can generate the Enter instruction properly
                                    program[enterInstLocation] =
                                      new Instruction(label, "Enter " +
                                                      (currentScope.Count(s => s.Item2 == (int)TastierKind.Var) + currentScope.Count(s => s.Item2 == (int)TastierKind.Const)));
                                    openProcedureDeclarations.Pop();
                                .).

/*------------------------------------------------------------------------*/

RelOp<out Instruction inst>
=                               (.  inst = new Instruction("", "Equ"); .)
  ( "="
  | '<'                         (.  inst = new Instruction("", "Lss"); .)
  | '>'                         (.  inst = new Instruction("", "Gtr"); .)
  | "!="                        (.  inst = new Instruction("", "NtEqu"); .)   //new not equal operator
  | "<="                        (.  inst = new Instruction("", "LssEq"); .)   //new less than or equal to operator
  | ">="                        (.  inst = new Instruction("", "GtrEq"); .)   //new greater than or equal to operator
  ).

/*------------------------------------------------------------------------*/

SimExpr<out int type, out int dim> (.  int type1; int dim1; Instruction inst; .)
= Term<out type, out dim>
  { AddOp<out inst>
    Term<out type1, out dim1>      (.
                                      if (type != (int)TastierType.Integer || type1 != (int)TastierType.Integer ||
                                          dim != 0 || dim1 != 0) {
                                        SemErr("integer type expected");
                                      }
                                      program.Add(inst);
                                    .)
  }.

/*------------------------------------------------------------------------*/
/*I created a production for assignment that has an optional conditional part.
  This means that where ever a normal assignment is used, a conditional
  assignment can also be used. This prevents a lot of code repetition
  in places like the for loop.
*/
Assignment<out int type, out int dim>(. int type1; int type2; int dim1; int dim2; .)

=
  Expr<out type, out dim>
  [
  '?'                           (.
                                    /* The conditional assignment statement is converted into an
                                       if-else structure in the assembly. This allows us to add
                                       conditional assignment to the language without altering the
                                       virtual machine.
                                    */
                                    if ((type != (int)TastierType.Boolean) || (dim != 0)) {
                                      SemErr("Boolean expression expected in conditional assignment");
                                    }
                                    program.Add(new Instruction("","Const 1"));
                                    program.Add(new Instruction("","Equ"));
                                    //start of if
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek()));
                                .)
  Expr<out type1,out dim1>
  ':'                           (.
                                    Instruction startOfElse = new Instruction(openLabels.Pop(), "Nop");
                                    openLabels.Push(generateLabel());
                                    //jump over else
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    //add label to allow jumping to else
                                    program.Add(startOfElse);
                                .)
  Expr<out type2,out dim2>      (.
                                    //check that the type of expression 1 is the same as expression 2
                                    if((type2 != type1) && (dim1 == dim2)) {
                                      SemErr("Types mismatch in conditional assignment");
                                    }
                                    //set type of assignment
                                    type = type2;
                                    dim = dim2;

                                    //end if-else
                                    program.Add(new Instruction(openLabels.Pop(), "Nop"));
                                .)
  ].

/*------------------------------------------------------------------------*/

Stat                            (.  int type; int type1; int type2; string name; string name1;
                                    Symbol sym; int dim; int dim1; int dim2;
                                    bool external = false; bool isExternal = false; Program incrementer;
                                    int arrayAccessType; bool firstAccess = true; bool isRecordOrArrayAccess = false;
                                    int dimensions = 0;
                                .)

= Ident<out name>               (.
                                    dim = 0;
                                    sym = lookup(openScopes, name);
                                    if (sym == null) {
                                      sym = _lookup(externalDeclarations, name);
                                      isExternal = true;
                                    }
                                    if (sym == null) {
                                      SemErr("reference to undefined variable " + name);
                                    } else {
                                      dim = sym.Item6;
                                      dimensions = sym.Item6;
                                      //if record or array then load pointer
                                      if((sym.Item3 > maxSystemType) || (sym.Item6 != 0)) {
                                        if (sym.Item4 == 0) {
                                          if (isExternal) {
                                            program.Add(new Instruction("", "LoadG " + sym.Item1));
                                            // if the symbol is external, we load it by name. The linker will resolve the name to an address.
                                          } else {
                                            program.Add(new Instruction("", "LoadG " + (sym.Item5+3)));
                                          }
                                        } else {
                                          int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                          program.Add(new Instruction("", "Load " + lexicalLevelDifference + " " + sym.Item5));
                                        }
                                      }
                                    }
                                .)
  {
    (
    access                      (.
                                  if(sym.Item3 <= maxSystemType || dimensions != 0) {
                                    SemErr("The access operator \'.\' can only be used for record reference variables");
                                  }
                                .)
    Ident<out name>             (.
                                    if(firstAccess) {
                                      isRecordOrArrayAccess = true;
                                      firstAccess = false;
                                    } else {
                                      program.Add(new Instruction("","MemLoad"));
                                    }

                                    sym = recordVariableLookup(sym.Item3,name);
                                    if(sym == null) {
                                      SemErr(name + " is not defined in referenced record");
                                    } else {
                                      type = sym.Item3;
                                      dim = sym.Item6;
                                      dimensions = sym.Item6;
                                      program.Add(new Instruction("","Const " + (sym.Item5)));
                                      program.Add(new Instruction("","Add"));
                                    }
                                .)

      |'['                        (.
                                    if(firstAccess) {
                                      isRecordOrArrayAccess = true;
                                      firstAccess = false;
                                    } else {
                                      program.Add(new Instruction("","MemLoad"));
                                    }
                                .)
      Expr<out arrayAccessType, out dim1>  (.
                                  dimensions--;
                                  if(dimensions < 0) {
                                    SemErr("Too many array accesses [ ]");
                                  }

                                  if((arrayAccessType != (int)TastierType.Integer) || (dim1 != 0)) {
                                    SemErr("Integer type expected for array access");
                                  }

                                  program.Add(new Instruction("","Add"));
                                .)
      ']'
      )
  }
  (":="                          (.

                                    //error if user tries to reassign constant
                                    if ((TastierKind)sym.Item2 == TastierKind.Const) {
                                      SemErr("cannot re-assign a constant");
                                    }
                                    else if ((TastierKind)sym.Item2 != TastierKind.Var) {
                                      SemErr("cannot assign to non-variable");
                                    }
                                .)
   Assignment<out type,out dim> (.
                                    if(sym.Item3 != type) {
                                      SemErr("Incompatible types");
                                    } else if(dimensions!= dim) {
                                      SemErr("Dimensions of arrays do not match");
                                    }
                                .)
   ';'                          (.
                                    if(!isRecordOrArrayAccess) {
                                      if (sym.Item4 == 0) {
                                        if (isExternal) {
                                          program.Add(new Instruction("", "StoG " + sym.Item1));
                                          // if the symbol is external, we also store it by name. The linker will resolve the name to an address.
                                        } else {
                                          program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                        }
                                      }
                                      else {
                                        int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                        program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                      }
                                    } else {
                                      program.Add(new Instruction("","MemStore"));
                                    }
                                .)
  | "allocate"  '('             (.
                                    //no need for load instruction if accessing base pointer or record or array
                                    if(!isRecordOrArrayAccess) {
                                      program.RemoveAt(program.Count() - 1);
                                    }

                                    if((sym.Item3 <= maxSystemType) && (sym.Item6 == 0)) {
                                      SemErr("Allocate can only be used for records and arrays");
                                    }
                                .)
    ( "record"
      Ident<out name>           (.
                                    bool found = false;
                                    int variableIndex = -1;
                                    foreach(RecordType rec in recordTypes) {
                                      if(rec.Item1.Equals(name)) {
                                        found = true;
                                        variableIndex = rec.Item3;
                                      }
                                    }

                                    if(found) {
                                      int recordSize = recordVariables[variableIndex].Count();
                                      //get next heap pointer
                                      program.Add(new Instruction("","LoadG 3"));

                                      //add memory offset
                                      program.Add(new Instruction("","Const 3"));
                                      program.Add(new Instruction("","Add"));

                                      //increment heap counter
                                      program.Add(new Instruction("","LoadG 3"));
                                      program.Add(new Instruction("","Const " + recordSize));
                                      program.Add(new Instruction("","Add"));
                                      program.Add(new Instruction("","StoG 3"));
                                    } else {
                                      SemErr("A record of type " + name + " has not been declared");
                                    }
                                .)
    | Expr<out type,out dim>    (.
                                    if(type != (int)TastierType.Integer || dim != 0) {
                                      SemErr("Allocate can only take expressions of type Integer or a record definition");
                                    }
                                    //store size of allocation temporarily
                                    program.Add(new Instruction("","StoG 4"));

                                    //get next heap pointer
                                    program.Add(new Instruction("","LoadG 3"));
                                    //add memory offset
                                    program.Add(new Instruction("","Const 3"));
                                    program.Add(new Instruction("","Add"));

                                    //increment heap counter
                                    program.Add(new Instruction("","LoadG 3"));
                                    program.Add(new Instruction("","LoadG 4")); //retrieve temporarily store address
                                    program.Add(new Instruction("","Add"));
                                    program.Add(new Instruction("","StoG 3"));

                                .)
    )
    ')'
    ';'                         (.
                                    if(!isRecordOrArrayAccess) {
                                      if (sym.Item4 == 0) {
                                        if (isExternal) {
                                          program.Add(new Instruction("", "StoG " + sym.Item1));
                                          // if the symbol is external, we also store it by name. The linker will resolve the name to an address.
                                        } else {
                                          program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                        }
                                      }
                                      else {
                                        int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                        program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                      }
                                    } else {
                                      program.Add(new Instruction("","MemStore"));
                                    }
                                .)


  | '(' ')' ';'                 (.
                                    if ((TastierKind)sym.Item2 != TastierKind.Proc) {
                                      SemErr("object is not a procedure");
                                    }

                                    int currentStackLevel = openScopes.Count;
                                    int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4);
                                    string procedureLabel = getLabelForProcedureName(lexicalLevelDifference, sym.Item1);

                                    if(sym.Item3 == (int)TastierType.Undefined) {
                                      program.Add(new Instruction("", "Call " + lexicalLevelDifference + " " + procedureLabel));
                                    } else {
                                      program.Add(new Instruction("", "CallNonVoid " + lexicalLevelDifference + " " + procedureLabel));
                                    }
                                .)
  )

| "if"
  '(' Expr<out type,out dim> ')'(.
                                    if (type != (int)TastierType.Boolean) {
                                      SemErr("boolean type expected");
                                    }
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek()));
                                .)
      Stat                      (.
                                    Instruction startOfElse = new Instruction(openLabels.Pop(), "Nop");
                                    /*
                                       If we got into the "if", we need to
                                       jump over the "else" so that it
                                       doesn't get executed.
                                    */
                                    openLabels.Push(generateLabel());
                                    program.Add(new Instruction("", "Jmp " + openLabels.Peek()));
                                    program.Add(startOfElse);
                                .)
      [ "else"
        Stat
      ]                         (.  program.Add(new Instruction(openLabels.Pop(), "Nop")); .)
| "switch"                      (.  Program cases = new Program();
                                    //create a new list of instructions to store case statements that will be
                                    //added before the switch structure.

                                    Program switchParameter = new Program();
                                    //create a new list of instructions that places the value upon which the
                                    //switch is acting back on the top of the stack

                                    program.Add(new Instruction("casesMarker",""));
                                    //create a marker in order to insert the cases statements

                                    Queue<string> caseLabels = new Queue<string>();
                                    //create queue to store the labels for the cases

                                    bool isDefault = false;
                                    //there is no need for an additional branch always if there is a default
                                    //this allows that additional branch always to be left out
                                .)
  '('                           (.
                                    //place a label here as a marker so that the instructions to place
                                    //the switch value back on the top of the stack can be found
                                    program.Add(new Instruction("switchValueMarker",""));
                                .)
  Expr<out type,out dim> ')' '{'(.
                                    int index = program.Count() - 1;
                                    int size = 0;
                                    bool markerFound = false;
                                    Instruction inst;
                                    while(!markerFound) {
                                      inst = program.ElementAt(index);
                                      if(inst.Item1 == "switchValueMarker") {
                                        markerFound = true;
                                        //store switch value
                                        switchParameter.AddRange(program.GetRange(index + 1,size));
                                        //delete marker from instructions list
                                        program.RemoveRange(index,size+1);
                                        //delete instructions from program, will be used in case statements
                                      }
                                      index--;
                                      size++;
                                    }
                                    if (((type != (int)TastierType.Integer) && (type != (int)TastierType.String)) || (dim != 0)){
                                      SemErr("integer or string type expected");
                                    }
                                    string endLabel = generateLabel();
                                .)
  {
    "case"                      (.
                                    //place switch value onto top of stack
                                    cases.AddRange(switchParameter);
                                    string newCaseLabel = generateLabel();
                                    program.Add(new Instruction(newCaseLabel,"Nop"));

                                    //keep label later for use in case part of switch
                                    caseLabels.Enqueue(newCaseLabel);

                                    //place marker for case value in program
                                    //this will be used to move the instructions
                                    //necessary to place the case value on the stack
                                    //into the cases list of instructions
                                    program.Add(new Instruction("caseMarker",""));

                                .)
    Expr<out type1,out dim1>    (.
                                    if(type != type1 || dim != 0 || dim1 != 0) {
                                      SemErr("Type of case statement does not match type of switch statement");
                                    }
                                    index = program.Count() - 1;
                                    size = 0;
                                    markerFound = false;
                                    while(!markerFound) {
                                      inst = program.ElementAt(index);
                                      if(inst.Item1 == "caseMarker") {
                                        markerFound = true;
                                        //store case value
                                        cases.AddRange(program.GetRange(index + 1,size));
                                        //delete marker from instructions list
                                        program.RemoveRange(index,size+1);
                                        //delete instructions from program, will be used in case statements
                                      }
                                      index--;
                                      size++;
                                    }

                                    //add marker to know when to insert jump instruction
                                    cases.Add(new Instruction("nextLabelMarker",""));
                                  .)
    ':' {Stat}
    [ "break" ';'                 (.
                                      program.Add(new Instruction("","Jmp " + endLabel));
                                  .)
    ]
  }
  [
    "default" ':'                 (.
                                      isDefault = true;
                                      string newCaseLabel = generateLabel();
                                      program.Add(new Instruction(newCaseLabel,"Nop"));

                                      //keep label later for use in case part of switch
                                      caseLabels.Enqueue(newCaseLabel);
                                  .)
    {Stat}
  ]
  '}'                             (.
                                      //end of switch statement
                                      program.Add(new Instruction(endLabel, "Nop"));

                                      Program fullCases = new Program();

                                      string nextCaseLabel;
                                      foreach (Instruction ins in cases) {
                                        if(ins.Item1 != "nextLabelMarker") {
                                          fullCases.Add(ins);
                                        } else {
                                          fullCases.Add(new Instruction("", "Equ"));
                                          nextCaseLabel = generateLabel();
                                          fullCases.Add(new Instruction("", "FJmp " + nextCaseLabel));
                                          fullCases.Add(new Instruction("", "Jmp " + caseLabels.Dequeue()));
                                          fullCases.Add(new Instruction(nextCaseLabel, "Nop"));
                                        }
                                      }
                                      if(isDefault) {
                                        fullCases.Add(new Instruction("","Jmp " + caseLabels.Dequeue()));
                                      } else {
                                        fullCases.Add(new Instruction("","Jmp " + endLabel));
                                      }

                                      Program tmp = new Program();
                                      //inserting cases part before case statements
                                      index = program.Count() - 1;
                                      size = 0;
                                      markerFound = false;
                                      while(!markerFound) {
                                        inst = program.ElementAt(index);
                                        if(inst.Item1 == "casesMarker") {
                                          markerFound = true;
                                          //store case value
                                          tmp.AddRange(program.GetRange(index + 1,size));
                                          //delete marker from instructions list
                                          program.RemoveRange(index,size+1);
                                          //delete instructions from program, will be used in case statements
                                        }
                                        index--;
                                        size++;
                                      }

                                      program.AddRange(fullCases);
                                      program.AddRange(tmp);
                                  .)

| "for"
  '('
  [Ident<out name>
  ":="
  Assignment<out type,out dim>    (.
                                    //optional assignment statement at start of for loop

                                    //This is placed before the loop begins as it only need to
                                    //happen once.

                                    sym = lookup(openScopes, name);
                                    if (sym == null) {
                                      sym = _lookup(externalDeclarations, name);
                                      isExternal = true;
                                    }
                                    if (sym == null) {
                                      SemErr("reference to undefined variable " + name);
                                    }

                                    if (type != sym.Item3 || sym.Item6 != dim) {
                                      SemErr("incompatible types");
                                    }

                                    if (dim != 0) {
                                      SemErr("Array pointers cannot be used in switch statements");
                                    }
                                    if (sym.Item4 == 0) {
                                      if (isExternal) {
                                        program.Add(new Instruction("", "StoG " + sym.Item1));
                                        // if the symbol is external, we also store it by name. The linker will resolve the name to an address.
                                      } else {
                                        program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                      }
                                    }
                                    else {
                                      int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                      program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                    }
                                .)
  ]
  ';'                           (.
                                    //create label that program can jump back to
                                    string loopStartLabel = generateLabel();
                                    openLabels.Push(generateLabel()); //second label is for the loop end
                                    program.Add(new Instruction(loopStartLabel, "Nop"));
                                .)
  Expr<out type1,out dim1>      (.
                                    //add condition check to the loop, the expression must be boolean
                                    if(type1 != (int)TastierType.Boolean || dim1 != 0) {
                                      SemErr("For loop condition must be type boolean ");
                                    }
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek())); // jump to the loop end label if condition is false
                                .)
  ';'
  Ident<out name1>
  ":="
  Assignment<out type2,out dim2> (.
                                    /* The last part of the for loop updates the loop variable
                                       The variable cannot be updated at the start of the loop
                                       because then the value of the variable will be incorrect
                                       during the loop.

                                       The assignment production computes the new value for the
                                       variable and leaves it on the stack. Rather than moving the
                                       instruction for the increment part to the end of the loop,
                                       which is complicated, I leave the new value of the variable
                                       on the stack (it shouldn't be used by anything else) and
                                       delay the storing of the new value into the memory location
                                       for the variable until the end of the loop . This accomplishes
                                       the same thing as putting the increment instructions at the
                                       end of the loop but it keeps things much simpler
                                    */

                                    /* only the instruction for storing the new value of the loop variable are delayed
                                       this instruction is temporarily stored in "incrementer", where it will be retrieved
                                       later
                                    */
                                    incrementer = new Program();
                                    sym = lookup(openScopes, name1);
                                    if (sym == null) {
                                      sym = _lookup(externalDeclarations, name1);
                                      isExternal = true;
                                    }
                                    if (sym == null) {
                                      SemErr("reference to undefined variable " + name1);
                                    } else {
                                      if (type2 != sym.Item3 || dim2 != sym.Item6) {
                                        SemErr("incompatible types");
                                      }
                                      if (sym.Item4 == 0) {
                                        if (isExternal) {
                                          incrementer.Add(new Instruction("", "StoG " + sym.Item1));
                                          // if the symbol is external, we also store it by name. The linker will resolve the name to an address.
                                        } else {
                                          incrementer.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                        }
                                      }
                                      else {
                                        int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                        incrementer.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                      }
                                    }
                                .)
  ')'
      Stat                      (.
                                    //we now store the new value of the loop variable into its memory location, updating it
                                    program.AddRange(incrementer);

                                    //jump back to the start of the loop
                                    program.Add(new Instruction("", "Jmp " + loopStartLabel));

                                    // put the loop end label here
                                    program.Add(new Instruction(openLabels.Pop(), "Nop"));
                                .)

| "while"                       (.  string loopStartLabel = generateLabel();
                                    openLabels.Push(generateLabel()); //second label is for the loop end
                                    program.Add(new Instruction(loopStartLabel, "Nop"));
                                .)
  '(' Expr<out type,out dim> ')'(.
                                    if (type != (int)TastierType.Boolean || dim != 0) {
                                      SemErr("boolean type expected");
                                    }
                                    program.Add(new Instruction("", "FJmp " + openLabels.Peek())); // jump to the loop end label if condition is false
                                .)
      Stat                      (.  program.Add(new Instruction("", "Jmp " + loopStartLabel));
                                    program.Add(new Instruction(openLabels.Pop(), "Nop")); // put the loop end label here
                                .)

| "read"
  Ident<out name> ';'           (.
                                    sym = lookup(openScopes, name);
                                    if (sym == null) {
                                      sym = _lookup(externalDeclarations, name);
                                      isExternal = true;
                                    }
                                    if (sym == null) {
                                      SemErr("reference to undefined variable " + name);
                                    }

                                    if (sym.Item2 != (int)TastierKind.Var) {
                                      SemErr("variable type expected but " + sym.Item1 + " has kind " + (TastierType)sym.Item2);
                                    }

                                    if (sym.Item3 != (int)TastierType.Integer || sym.Item6 != 0) {
                                      SemErr("integer type expected but " + sym.Item1 + " has type " + (TastierType)sym.Item2);
                                    }
                                    program.Add(new Instruction("", "Read"));

                                    if (sym.Item4 == 0) {
                                      if (isExternal) {
                                        program.Add(new Instruction("", "StoG " + sym.Item1));
                                        // if the symbol is external, we also store it by name. The linker will resolve the name to an address.
                                      } else {
                                        program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                      }
                                    }
                                    else {
                                      int lexicalLevelDifference = Math.Abs(openScopes.Count - sym.Item4)-1;
                                      program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + sym.Item5));
                                    }
                                .)

| "write"
  Expr<out type,out dim>        (.
                                    /*
                                      There are 3 types of write instructions.
                                        1) Write: outputs value on top of stack
                                        2) WriteStr: outputs the string pointed to by the value
                                           on top of the stack.
                                        3) WriteMul: Takes multiple args and outputs them as a
                                           single string. In order to do this WriteMul must know
                                           whether the value is a value or a pointer. This is
                                           done by placing the type of the argument on the stack
                                           in front of the value/pointer. The number of arguments
                                           is then placed on the stack.

                                        A better explantion of these instructions
                                        is contained in TastierMachine/TastierMachine/Instructions.hs
                                    */

                                    if (type == (int)TastierType.Integer && dim == 0) {
                                      //needed for WriteMul
                                      program.Add(new Instruction("", "Const " + (int)type));
                                    } else if (type == (int)TastierType.String && dim == 0) {
                                      //needed for WriteMul
                                      program.Add(new Instruction("", "Const " + (int)type));
                                    } else {
                                      SemErr("unexpected variable type: " + type);
                                    }
                                    numArgs = 1;
                                 .)
  { ',' Expr<out type,out dim>  (.
                                    numArgs++;
                                    if(((type != (int)TastierType.String) && (type != (int)TastierType.Integer)) || (dim != 0)) {
                                      SemErr("unexpected variable type: " + type);
                                    }
                                    //needed for WriteMul
                                    program.Add(new Instruction("", "Const " + (int)type));
                                .)
  } ';'                         (.
                                    if(numArgs == 1) {
                                      //no need for WriteMul so we can remove type placed on stack
                                      program.RemoveAt(program.Count()-1);
                                      if (type == (int)TastierType.Integer) {
                                        program.Add(new Instruction("", "Write"));
                                      } else if (type == (int)TastierType.String) {
                                        program.Add(new Instruction("", "WriteStr"));
                                      }
                                    } else {
                                      program.Add(new Instruction("", "Const " + (numArgs)));
                                      program.Add(new Instruction("", "WriteMul"));
                                    }
                                .)

| '{' { Stat | VarDecl<external> } '}' .

/*------------------------------------------------------------------------*/

Tastier                         (.  string name; bool external = false; .)
= "program"
  Ident<out name>               (.
                                    openScopes.Push(new Scope());
                                    if(name.Contains('.')) {
                                      SemErr("Character \'.\' character be used in identifer");
                                    }
                                .)
  '{'
  { ConstDecl | RecordDecl }{ VarDecl<external> | ProcDecl | ExternDecl }
  '}'                           (.
                                    if (openScopes.Peek().Count == 0) {
                                      Warn("Warning: Program " + name + " is empty ");
                                    }
                                    header.Add(new Instruction("", ".names " + (externalDeclarations.Count + openScopes.Peek().Count)));
                                    foreach (Symbol s in openScopes.Peek()) {
                                      if ((s.Item2 == (int)TastierKind.Var) || (s.Item2 == (int)TastierKind.Const)) {
                                        header.Add(new Instruction("", ".var " + ((int)s.Item3) + " " + s.Item1));
                                      } else if (s.Item2 == (int)TastierKind.Proc) {
                                        header.Add(new Instruction("", ".proc " + s.Item1));
                                      } else {
                                        SemErr("global item " + s.Item1 + " has no defined type");
                                      }
                                    }
                                    foreach (Symbol s in externalDeclarations) {
                                      if (s.Item2 == (int)TastierKind.Var) {
                                        header.Add(new Instruction("", ".external var " + ((int)s.Item3) + " " + s.Item1));
                                      } else if (s.Item2 == (int)TastierKind.Proc) {
                                        header.Add(new Instruction("", ".external proc " + s.Item1));
                                      } else {
                                        SemErr("external item " + s.Item1 + " has no defined type");
                                      }
                                    }

                                    //add function that initialises the heap memory counter
                                    header.Add(new Instruction("InitHeapCounter","Enter 0"));
                                    header.Add(new Instruction("","Const " + nextHeapAddress));
                                    header.Add(new Instruction("","StoG 3"));
                                    header.Add(new Instruction("","Leave"));
                                    header.Add(new Instruction("","Ret"));

                                    /*
                                      Need to add empty function if constants are not declared
                                      as ConstDecl is the first function called by machine.
                                    */
                                    if(!constantsDeclared) {
                                      header.Add(new Instruction("ConstDecl", "Enter 0"));
                                      header.Add(new Instruction("","Leave"));
                                      header.Add(new Instruction("","Ret"));
                                    }
                                    header.AddRange(program);
                                    openScopes.Pop();
                                .).

/*------------------------------------------------------------------------*/

Term<out int type, out int dim> (.  int type1; int dim1; Instruction inst; .)
= Factor<out type,out dim>
  { MulOp<out inst>
    Factor<out type1,out dim1>  (.
                                    if ((type != (int)TastierType.Integer) ||
                                        (type1 != (int)TastierType.Integer) ||
                                        (dim != 0) ||
                                        (dim1 != 0)) {
                                      SemErr("integer type expected");
                                    }
                                    program.Add(inst);
                                .)
  }.
/*------------------------------------------------------------------------*/

Type<out int type>
=                               (.  type = (int)TastierType.Undefined; .)
 ( "int"                        (.  type = (int)TastierType.Integer; .)
 | "bool"                       (.  type = (int)TastierType.Boolean; .)
 | "string"                     (.  type = (int)TastierType.String;  .)
 ).

/*------------------------------------------------------------------------*/
ConstDecl                       (.
                                    string name; int type; int dim; Scope currentScope = openScopes.Peek();
                                    Symbol sym;

                                    if(!constantsDeclared) {
                                      program.Add(new Instruction("ConstDecl", "Enter 0"));
                                      constantsDeclared = true;
                                    } else {
                                      /*
                                        We cannot know ahead of time how many constants are
                                        declared. So after each constant is declared we add
                                        "Leave" and "Ret" instructions. So when another constant
                                        is declared, these must be removed before the rest of
                                        the instructions are added.
                                      */
                                      program.RemoveRange(program.Count-2,2);
                                    }
                                .)
= "const"
  Type<out type>
  Ident<out name>               (.
                                    int memLocation;
                                    //if global variable, need to determine next free heap address and increment heap address counter
                                    if(openScopes.Count()-1 == 0) {
                                      memLocation = nextHeapAddress;
                                      nextHeapAddress++;
                                    } else {
                                      memLocation = (currentScope.Count(s => s.Item2 == (int)TastierKind.Var) + currentScope.Count(s => s.Item2 == (int)TastierKind.Const));
                                    }
                                    sym = new Symbol(name, (int)TastierKind.Const, (int)type, openScopes.Count-1, memLocation, 0);
                                    currentScope.Push(sym);
                                .)
  ":="
  Expr<out type,out dim>        (.
                                    if (type != sym.Item3) {
                                      SemErr("incompatible types");
                                    } else if (type > maxSystemType || dim != 0) {
                                      SemErr("constants can only be declared for non array system types");
                                    }
                                    program.Add(new Instruction("", "StoG " + (sym.Item5+3)));
                                .)
   ';'                         (.
                                    program.Add(new Instruction("", "Leave"));
                                    program.Add(new Instruction("", "Ret"));
                                .).

/*------------------------------------------------------------------------*/
RecordDecl                      (.
                                    bool external = false; string typeName; int type; Scope currentScope = openScopes.Peek(); Symbol sym;
                                .)
= "create"
  "record"
  Ident<out typeName>            (.
                                    foreach(RecordType rec in recordTypes) {
                                      if(rec.Item1.Equals(typeName)) {
                                        SemErr(typeName + " has already been declared");
                                      }
                                    }

                                    //Adding new record type to list and giving it its own list of variables
                                    type = typesDefined;
                                    typesDefined++;
                                    int variableIndex = recordsDefined;
                                    recordTypes.Add(new RecordType(typeName,type,variableIndex));
                                    recordsDefined++;

                                    recordVariables.Add(new List<Symbol>());
                                    currentScope.Push(new Symbol("@RecordMarker", -1, -1, -1, -1, -1));

                                    //need to undo any changes made by variables declared within records
                                    //so backups are created here to undo any changes
                                    int nextHeapAddressBackup = nextHeapAddress;
                                    Program programBackup = new Program();
                                    programBackup.AddRange(program);

                                .)
  '{'
  VarDecl<external>
  {
  VarDecl<external>
  }
  '}'                           (.
                                    //Remove symbol from global symbol table and add it to symbol table for record
                                    sym = currentScope.Pop();
                                    sym = new Symbol(sym.Item1, sym.Item2, sym.Item3, sym.Item4, -1, sym.Item6);
                                    while(sym.Item1 != "@RecordMarker") {
                                      recordVariables.ElementAt(variableIndex).Add(sym);
                                      sym = currentScope.Pop();
                                      sym = new Symbol(sym.Item1, sym.Item2, sym.Item3, sym.Item4, -1, sym.Item6);
                                    }

                                    //stack returns variables in reverse order
                                    recordVariables[variableIndex].Reverse();


                                    //undo changes
                                    nextHeapAddress = nextHeapAddressBackup;
                                    program = programBackup;


                                    int index = 0;
                                    foreach(Symbol s in recordVariables.ElementAt(variableIndex)) {
                                      recordVariables.ElementAt(variableIndex)[index] = new Symbol(s.Item1,s.Item2,s.Item3,s.Item4,index,s.Item6);
                                      index++;
                                    }

                                .).

/*------------------------------------------------------------------------*/

VarDecl<bool external>          (.
                                    string name; int type; Scope currentScope = openScopes.Peek();
                                    string typeName; string varName; int dimensions = 0;
                                .)
= (Type<out type>
   {
      '[' ']'                   (.
                                    dimensions++;
                                .)
   }
   Ident<out name>        (.
                                    //check that there are no name collisions
                                    Symbol checkNoCollisions = lookup(openScopes,name);
                                    if(checkNoCollisions != null) {
                                      SemErr("Variable name " + name + " is already in use");
                                    }

                                    if (external) {
                                      externalDeclarations.Push(new Symbol(name, (int)TastierKind.Var, (int)type, 0, 0, 0));
                                    } else {
                                      int address;
                                      //if in global scope, need to find next available heap location and increment heap address counter
                                      if((openScopes.Count-1) == 0) {
                                        address = nextHeapAddress;
                                        nextHeapAddress++;
                                      } else {
                                        address = (currentScope.Count(s => s.Item2 == (int)TastierKind.Var) + currentScope.Count(s => s.Item2 == (int)TastierKind.Const));
                                      }
                                      currentScope.Push(new Symbol(name, (int)TastierKind.Var, type, openScopes.Count-1, address, dimensions));
                                    }


                                .)
   { ',' Ident<out name>  (.
                                    //check that there are no name collisions
                                    checkNoCollisions = lookup(openScopes,name);
                                    if(checkNoCollisions != null) {
                                      SemErr("Variable name " + name + " is already in use");
                                    }

                                    if (external) {
                                      externalDeclarations.Push(new Symbol(name, (int)TastierKind.Var, (int)type, 0, 0, 0));
                                    } else {
                                      int address;
                                      //if in global scope, need to find next available heap location and increment heap address counter
                                      if((openScopes.Count-1) == 0) {
                                        address = nextHeapAddress;
                                        nextHeapAddress++;
                                      } else {
                                        address = (currentScope.Count(s => s.Item2 == (int)TastierKind.Var) + currentScope.Count(s => s.Item2 == (int)TastierKind.Const));
                                      }
                                      currentScope.Push(new Symbol(name, (int)TastierKind.Var, (int)type, openScopes.Count-1, address,dimensions));
                                    }

                                .)
  } ';'
  | "record"
    Ident<out typeName>         (.
                                    RecordType recType = null;
                                    foreach(RecordType rec in recordTypes) {
                                      if(rec.Item1.Equals(typeName)) {
                                        recType = rec;
                                      }
                                    }
                                    if(recType == null) {
                                      SemErr("Record " + typeName + " has not been declared");
                                      type = (int)TastierType.Undefined;
                                    } else {
                                      type = recType.Item2;
                                    }
                                .)
    {
      '[' ']'                   (.
                                    dimensions++;
                                .)
   }
    Ident<out varName>          (.
                                    //check that there are no name collisions
                                    Symbol checkNoCollisions = lookup(openScopes,varName);
                                    if(checkNoCollisions != null) {
                                      SemErr("Variable name " + varName + " is already in use");
                                    }

                                    //create new instance of record in current scope
                                    int address;
                                    //if in global scope, need to find next available heap location and increment heap address counter
                                    if((openScopes.Count-1) == 0) {
                                      address = nextHeapAddress;
                                      nextHeapAddress++;
                                    } else {
                                      address = (currentScope.Count(s => s.Item2 == (int)TastierKind.Var) + currentScope.Count(s => s.Item2 == (int)TastierKind.Const));
                                    }
                                    currentScope.Push(new Symbol(varName, (int)TastierKind.Var, (int)type,openScopes.Count-1, address,dimensions));

                                    /*if(!isArray) {

                                      int stringAddress = nextHeapAddress;
                                      nextHeapAddress = nextHeapAddress + recordType.Item3;

                                      program.Add(new Instruction("","Const " + Convert.ToString(stringAddress + 3)));

                                      if ((openScopes.Count-1) == 0) {
                                        if (external) {
                                          program.Add(new Instruction("", "StoG " + varName));
                                          // if the symbol is external, we also store it by name. The linker will resolve the name to an address.
                                        } else {
                                          program.Add(new Instruction("", "StoG " + (address+3)));
                                        }
                                      } else {
                                        //There is no need for a lexical difference here as the record has just been declared
                                        //in the current scope
                                        int lexicalLevelDifference = 0;
                                        program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + address));
                                      }
                                    } */
                                .)
    { ',' Ident<out varName>    (.
                                    //check that there are no name collisions
                                    checkNoCollisions = lookup(openScopes,varName);
                                    if(checkNoCollisions != null) {
                                      SemErr("Variable name " + varName + " is already in use");
                                    }


                                    //create new instance of record in current scope
                                    //if in global scope, need to find next available heap location and increment heap address counter
                                    if((openScopes.Count-1) == 0) {
                                      address = nextHeapAddress;
                                      nextHeapAddress++;
                                    } else {
                                      address = (currentScope.Count(s => s.Item2 == (int)TastierKind.Var) + currentScope.Count(s => s.Item2 == (int)TastierKind.Const));
                                    }
                                    currentScope.Push(new Symbol(varName, (int)TastierKind.Var, (int)type,openScopes.Count-1, address, dimensions));


                                    /*if(!isArray) {


                                      int stringAddress = nextHeapAddress;
                                      nextHeapAddress = nextHeapAddress + recordType.Item3;

                                      //pointer to record in memory, will be replaced with absolute address later
                                      program.Add(new Instruction("","Const " + Convert.ToString(stringAddress + 3)));

                                      if ((openScopes.Count-1) == 0) {
                                        if (external) {
                                          program.Add(new Instruction("", "StoG " + varName));
                                          // if the symbol is external, we also store it by name. The linker will resolve the name to an address.
                                        } else {
                                          program.Add(new Instruction("", "StoG " + (address+3)));
                                        }
                                      } else {
                                        //There is no need for a lexical difference here as the record has just been declared
                                        //in the current scope
                                        int lexicalLevelDifference = 0;
                                        program.Add(new Instruction("", "Sto " + lexicalLevelDifference + " " + address));
                                      }
                                    }*/
                                .)
  } ';'
  ).

ExternDecl                      (.  string name; bool external = true; Scope currentScope = openScopes.Peek(); int count = currentScope.Count; .)
= "external"
  ( VarDecl<external>
  | "procedure" Ident<out name> ';'
                                (.
                                    externalDeclarations.Push(new Symbol(name, (int)TastierKind.Proc, (int)TastierType.Undefined, 1, -1,0));
                                .)
  ) .

END Tastier.
